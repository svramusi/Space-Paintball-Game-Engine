// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameEngine.proto

#ifndef PROTOBUF_GameEngine_2eproto__INCLUDED
#define PROTOBUF_GameEngine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace net {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GameEngine_2eproto();
void protobuf_AssignDesc_GameEngine_2eproto();
void protobuf_ShutdownFile_GameEngine_2eproto();

class VelocityMessage;
class ForceMessage;
class PointMessage;
class CollidableObjectMessage;
class AabbMessage;
class SphereMessage;
class PhysicsInfoMessage;
class UpdateObjectMessage;
class DeleteObjectMessage;
class GameEngineMessage;

enum PhysicsInfoMessage_PhysicsInfoMessageType {
  PhysicsInfoMessage_PhysicsInfoMessageType_AABB = 0,
  PhysicsInfoMessage_PhysicsInfoMessageType_SPHERE = 1
};
bool PhysicsInfoMessage_PhysicsInfoMessageType_IsValid(int value);
const PhysicsInfoMessage_PhysicsInfoMessageType PhysicsInfoMessage_PhysicsInfoMessageType_PhysicsInfoMessageType_MIN = PhysicsInfoMessage_PhysicsInfoMessageType_AABB;
const PhysicsInfoMessage_PhysicsInfoMessageType PhysicsInfoMessage_PhysicsInfoMessageType_PhysicsInfoMessageType_MAX = PhysicsInfoMessage_PhysicsInfoMessageType_SPHERE;
const int PhysicsInfoMessage_PhysicsInfoMessageType_PhysicsInfoMessageType_ARRAYSIZE = PhysicsInfoMessage_PhysicsInfoMessageType_PhysicsInfoMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PhysicsInfoMessage_PhysicsInfoMessageType_descriptor();
inline const ::std::string& PhysicsInfoMessage_PhysicsInfoMessageType_Name(PhysicsInfoMessage_PhysicsInfoMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PhysicsInfoMessage_PhysicsInfoMessageType_descriptor(), value);
}
inline bool PhysicsInfoMessage_PhysicsInfoMessageType_Parse(
    const ::std::string& name, PhysicsInfoMessage_PhysicsInfoMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PhysicsInfoMessage_PhysicsInfoMessageType>(
    PhysicsInfoMessage_PhysicsInfoMessageType_descriptor(), name, value);
}
enum GameEngineMessage_GameEngineMessageType {
  GameEngineMessage_GameEngineMessageType_CREATE = 0,
  GameEngineMessage_GameEngineMessageType_RETRIEVE = 1,
  GameEngineMessage_GameEngineMessageType_UPDATE = 2,
  GameEngineMessage_GameEngineMessageType_DELETE = 3
};
bool GameEngineMessage_GameEngineMessageType_IsValid(int value);
const GameEngineMessage_GameEngineMessageType GameEngineMessage_GameEngineMessageType_GameEngineMessageType_MIN = GameEngineMessage_GameEngineMessageType_CREATE;
const GameEngineMessage_GameEngineMessageType GameEngineMessage_GameEngineMessageType_GameEngineMessageType_MAX = GameEngineMessage_GameEngineMessageType_DELETE;
const int GameEngineMessage_GameEngineMessageType_GameEngineMessageType_ARRAYSIZE = GameEngineMessage_GameEngineMessageType_GameEngineMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEngineMessage_GameEngineMessageType_descriptor();
inline const ::std::string& GameEngineMessage_GameEngineMessageType_Name(GameEngineMessage_GameEngineMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEngineMessage_GameEngineMessageType_descriptor(), value);
}
inline bool GameEngineMessage_GameEngineMessageType_Parse(
    const ::std::string& name, GameEngineMessage_GameEngineMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEngineMessage_GameEngineMessageType>(
    GameEngineMessage_GameEngineMessageType_descriptor(), name, value);
}
// ===================================================================

class VelocityMessage : public ::google::protobuf::Message {
 public:
  VelocityMessage();
  virtual ~VelocityMessage();

  VelocityMessage(const VelocityMessage& from);

  inline VelocityMessage& operator=(const VelocityMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelocityMessage& default_instance();

  void Swap(VelocityMessage* other);

  // implements Message ----------------------------------------------

  VelocityMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VelocityMessage& from);
  void MergeFrom(const VelocityMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:net.VelocityMessage)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static VelocityMessage* default_instance_;
};
// -------------------------------------------------------------------

class ForceMessage : public ::google::protobuf::Message {
 public:
  ForceMessage();
  virtual ~ForceMessage();

  ForceMessage(const ForceMessage& from);

  inline ForceMessage& operator=(const ForceMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceMessage& default_instance();

  void Swap(ForceMessage* other);

  // implements Message ----------------------------------------------

  ForceMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForceMessage& from);
  void MergeFrom(const ForceMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:net.ForceMessage)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static ForceMessage* default_instance_;
};
// -------------------------------------------------------------------

class PointMessage : public ::google::protobuf::Message {
 public:
  PointMessage();
  virtual ~PointMessage();

  PointMessage(const PointMessage& from);

  inline PointMessage& operator=(const PointMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointMessage& default_instance();

  void Swap(PointMessage* other);

  // implements Message ----------------------------------------------

  PointMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointMessage& from);
  void MergeFrom(const PointMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:net.PointMessage)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static PointMessage* default_instance_;
};
// -------------------------------------------------------------------

class CollidableObjectMessage : public ::google::protobuf::Message {
 public:
  CollidableObjectMessage();
  virtual ~CollidableObjectMessage();

  CollidableObjectMessage(const CollidableObjectMessage& from);

  inline CollidableObjectMessage& operator=(const CollidableObjectMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollidableObjectMessage& default_instance();

  void Swap(CollidableObjectMessage* other);

  // implements Message ----------------------------------------------

  CollidableObjectMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollidableObjectMessage& from);
  void MergeFrom(const CollidableObjectMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required .net.PointMessage center = 2;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 2;
  inline const ::net::PointMessage& center() const;
  inline ::net::PointMessage* mutable_center();
  inline ::net::PointMessage* release_center();
  inline void set_allocated_center(::net::PointMessage* center);

  // required int32 movable = 3;
  inline bool has_movable() const;
  inline void clear_movable();
  static const int kMovableFieldNumber = 3;
  inline ::google::protobuf::int32 movable() const;
  inline void set_movable(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:net.CollidableObjectMessage)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_movable();
  inline void clear_has_movable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::net::PointMessage* center_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 movable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static CollidableObjectMessage* default_instance_;
};
// -------------------------------------------------------------------

class AabbMessage : public ::google::protobuf::Message {
 public:
  AabbMessage();
  virtual ~AabbMessage();

  AabbMessage(const AabbMessage& from);

  inline AabbMessage& operator=(const AabbMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AabbMessage& default_instance();

  void Swap(AabbMessage* other);

  // implements Message ----------------------------------------------

  AabbMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AabbMessage& from);
  void MergeFrom(const AabbMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .net.CollidableObjectMessage collidableObject = 1;
  inline bool has_collidableobject() const;
  inline void clear_collidableobject();
  static const int kCollidableObjectFieldNumber = 1;
  inline const ::net::CollidableObjectMessage& collidableobject() const;
  inline ::net::CollidableObjectMessage* mutable_collidableobject();
  inline ::net::CollidableObjectMessage* release_collidableobject();
  inline void set_allocated_collidableobject(::net::CollidableObjectMessage* collidableobject);

  // required float radiusX = 2;
  inline bool has_radiusx() const;
  inline void clear_radiusx();
  static const int kRadiusXFieldNumber = 2;
  inline float radiusx() const;
  inline void set_radiusx(float value);

  // required float radiusY = 3;
  inline bool has_radiusy() const;
  inline void clear_radiusy();
  static const int kRadiusYFieldNumber = 3;
  inline float radiusy() const;
  inline void set_radiusy(float value);

  // required float radiusZ = 4;
  inline bool has_radiusz() const;
  inline void clear_radiusz();
  static const int kRadiusZFieldNumber = 4;
  inline float radiusz() const;
  inline void set_radiusz(float value);

  // @@protoc_insertion_point(class_scope:net.AabbMessage)
 private:
  inline void set_has_collidableobject();
  inline void clear_has_collidableobject();
  inline void set_has_radiusx();
  inline void clear_has_radiusx();
  inline void set_has_radiusy();
  inline void clear_has_radiusy();
  inline void set_has_radiusz();
  inline void clear_has_radiusz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::net::CollidableObjectMessage* collidableobject_;
  float radiusx_;
  float radiusy_;
  float radiusz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static AabbMessage* default_instance_;
};
// -------------------------------------------------------------------

class SphereMessage : public ::google::protobuf::Message {
 public:
  SphereMessage();
  virtual ~SphereMessage();

  SphereMessage(const SphereMessage& from);

  inline SphereMessage& operator=(const SphereMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SphereMessage& default_instance();

  void Swap(SphereMessage* other);

  // implements Message ----------------------------------------------

  SphereMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SphereMessage& from);
  void MergeFrom(const SphereMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .net.CollidableObjectMessage collidableObject = 1;
  inline bool has_collidableobject() const;
  inline void clear_collidableobject();
  static const int kCollidableObjectFieldNumber = 1;
  inline const ::net::CollidableObjectMessage& collidableobject() const;
  inline ::net::CollidableObjectMessage* mutable_collidableobject();
  inline ::net::CollidableObjectMessage* release_collidableobject();
  inline void set_allocated_collidableobject(::net::CollidableObjectMessage* collidableobject);

  // required float radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline float radius() const;
  inline void set_radius(float value);

  // @@protoc_insertion_point(class_scope:net.SphereMessage)
 private:
  inline void set_has_collidableobject();
  inline void clear_has_collidableobject();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::net::CollidableObjectMessage* collidableobject_;
  float radius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static SphereMessage* default_instance_;
};
// -------------------------------------------------------------------

class PhysicsInfoMessage : public ::google::protobuf::Message {
 public:
  PhysicsInfoMessage();
  virtual ~PhysicsInfoMessage();

  PhysicsInfoMessage(const PhysicsInfoMessage& from);

  inline PhysicsInfoMessage& operator=(const PhysicsInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicsInfoMessage& default_instance();

  void Swap(PhysicsInfoMessage* other);

  // implements Message ----------------------------------------------

  PhysicsInfoMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PhysicsInfoMessage& from);
  void MergeFrom(const PhysicsInfoMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PhysicsInfoMessage_PhysicsInfoMessageType PhysicsInfoMessageType;
  static const PhysicsInfoMessageType AABB = PhysicsInfoMessage_PhysicsInfoMessageType_AABB;
  static const PhysicsInfoMessageType SPHERE = PhysicsInfoMessage_PhysicsInfoMessageType_SPHERE;
  static inline bool PhysicsInfoMessageType_IsValid(int value) {
    return PhysicsInfoMessage_PhysicsInfoMessageType_IsValid(value);
  }
  static const PhysicsInfoMessageType PhysicsInfoMessageType_MIN =
    PhysicsInfoMessage_PhysicsInfoMessageType_PhysicsInfoMessageType_MIN;
  static const PhysicsInfoMessageType PhysicsInfoMessageType_MAX =
    PhysicsInfoMessage_PhysicsInfoMessageType_PhysicsInfoMessageType_MAX;
  static const int PhysicsInfoMessageType_ARRAYSIZE =
    PhysicsInfoMessage_PhysicsInfoMessageType_PhysicsInfoMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PhysicsInfoMessageType_descriptor() {
    return PhysicsInfoMessage_PhysicsInfoMessageType_descriptor();
  }
  static inline const ::std::string& PhysicsInfoMessageType_Name(PhysicsInfoMessageType value) {
    return PhysicsInfoMessage_PhysicsInfoMessageType_Name(value);
  }
  static inline bool PhysicsInfoMessageType_Parse(const ::std::string& name,
      PhysicsInfoMessageType* value) {
    return PhysicsInfoMessage_PhysicsInfoMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .net.PhysicsInfoMessage.PhysicsInfoMessageType physicsInfoMessageType = 1;
  inline bool has_physicsinfomessagetype() const;
  inline void clear_physicsinfomessagetype();
  static const int kPhysicsInfoMessageTypeFieldNumber = 1;
  inline ::net::PhysicsInfoMessage_PhysicsInfoMessageType physicsinfomessagetype() const;
  inline void set_physicsinfomessagetype(::net::PhysicsInfoMessage_PhysicsInfoMessageType value);

  // optional .net.AabbMessage aabbObject = 2;
  inline bool has_aabbobject() const;
  inline void clear_aabbobject();
  static const int kAabbObjectFieldNumber = 2;
  inline const ::net::AabbMessage& aabbobject() const;
  inline ::net::AabbMessage* mutable_aabbobject();
  inline ::net::AabbMessage* release_aabbobject();
  inline void set_allocated_aabbobject(::net::AabbMessage* aabbobject);

  // optional .net.SphereMessage sphereObject = 3;
  inline bool has_sphereobject() const;
  inline void clear_sphereobject();
  static const int kSphereObjectFieldNumber = 3;
  inline const ::net::SphereMessage& sphereobject() const;
  inline ::net::SphereMessage* mutable_sphereobject();
  inline ::net::SphereMessage* release_sphereobject();
  inline void set_allocated_sphereobject(::net::SphereMessage* sphereobject);

  // required float mass = 4;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 4;
  inline float mass() const;
  inline void set_mass(float value);

  // required .net.VelocityMessage linearVelocity = 5;
  inline bool has_linearvelocity() const;
  inline void clear_linearvelocity();
  static const int kLinearVelocityFieldNumber = 5;
  inline const ::net::VelocityMessage& linearvelocity() const;
  inline ::net::VelocityMessage* mutable_linearvelocity();
  inline ::net::VelocityMessage* release_linearvelocity();
  inline void set_allocated_linearvelocity(::net::VelocityMessage* linearvelocity);

  // required .net.ForceMessage linearForce = 6;
  inline bool has_linearforce() const;
  inline void clear_linearforce();
  static const int kLinearForceFieldNumber = 6;
  inline const ::net::ForceMessage& linearforce() const;
  inline ::net::ForceMessage* mutable_linearforce();
  inline ::net::ForceMessage* release_linearforce();
  inline void set_allocated_linearforce(::net::ForceMessage* linearforce);

  // required .net.VelocityMessage angularVelocity = 7;
  inline bool has_angularvelocity() const;
  inline void clear_angularvelocity();
  static const int kAngularVelocityFieldNumber = 7;
  inline const ::net::VelocityMessage& angularvelocity() const;
  inline ::net::VelocityMessage* mutable_angularvelocity();
  inline ::net::VelocityMessage* release_angularvelocity();
  inline void set_allocated_angularvelocity(::net::VelocityMessage* angularvelocity);

  // required .net.ForceMessage angularForce = 8;
  inline bool has_angularforce() const;
  inline void clear_angularforce();
  static const int kAngularForceFieldNumber = 8;
  inline const ::net::ForceMessage& angularforce() const;
  inline ::net::ForceMessage* mutable_angularforce();
  inline ::net::ForceMessage* release_angularforce();
  inline void set_allocated_angularforce(::net::ForceMessage* angularforce);

  // required .net.PointMessage angularPosition = 9;
  inline bool has_angularposition() const;
  inline void clear_angularposition();
  static const int kAngularPositionFieldNumber = 9;
  inline const ::net::PointMessage& angularposition() const;
  inline ::net::PointMessage* mutable_angularposition();
  inline ::net::PointMessage* release_angularposition();
  inline void set_allocated_angularposition(::net::PointMessage* angularposition);

  // @@protoc_insertion_point(class_scope:net.PhysicsInfoMessage)
 private:
  inline void set_has_physicsinfomessagetype();
  inline void clear_has_physicsinfomessagetype();
  inline void set_has_aabbobject();
  inline void clear_has_aabbobject();
  inline void set_has_sphereobject();
  inline void clear_has_sphereobject();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_linearvelocity();
  inline void clear_has_linearvelocity();
  inline void set_has_linearforce();
  inline void clear_has_linearforce();
  inline void set_has_angularvelocity();
  inline void clear_has_angularvelocity();
  inline void set_has_angularforce();
  inline void clear_has_angularforce();
  inline void set_has_angularposition();
  inline void clear_has_angularposition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::net::AabbMessage* aabbobject_;
  int physicsinfomessagetype_;
  float mass_;
  ::net::SphereMessage* sphereobject_;
  ::net::VelocityMessage* linearvelocity_;
  ::net::ForceMessage* linearforce_;
  ::net::VelocityMessage* angularvelocity_;
  ::net::ForceMessage* angularforce_;
  ::net::PointMessage* angularposition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static PhysicsInfoMessage* default_instance_;
};
// -------------------------------------------------------------------

class UpdateObjectMessage : public ::google::protobuf::Message {
 public:
  UpdateObjectMessage();
  virtual ~UpdateObjectMessage();

  UpdateObjectMessage(const UpdateObjectMessage& from);

  inline UpdateObjectMessage& operator=(const UpdateObjectMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateObjectMessage& default_instance();

  void Swap(UpdateObjectMessage* other);

  // implements Message ----------------------------------------------

  UpdateObjectMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateObjectMessage& from);
  void MergeFrom(const UpdateObjectMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required .net.PointMessage position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::net::PointMessage& position() const;
  inline ::net::PointMessage* mutable_position();
  inline ::net::PointMessage* release_position();
  inline void set_allocated_position(::net::PointMessage* position);

  // @@protoc_insertion_point(class_scope:net.UpdateObjectMessage)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::net::PointMessage* position_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static UpdateObjectMessage* default_instance_;
};
// -------------------------------------------------------------------

class DeleteObjectMessage : public ::google::protobuf::Message {
 public:
  DeleteObjectMessage();
  virtual ~DeleteObjectMessage();

  DeleteObjectMessage(const DeleteObjectMessage& from);

  inline DeleteObjectMessage& operator=(const DeleteObjectMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteObjectMessage& default_instance();

  void Swap(DeleteObjectMessage* other);

  // implements Message ----------------------------------------------

  DeleteObjectMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteObjectMessage& from);
  void MergeFrom(const DeleteObjectMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:net.DeleteObjectMessage)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static DeleteObjectMessage* default_instance_;
};
// -------------------------------------------------------------------

class GameEngineMessage : public ::google::protobuf::Message {
 public:
  GameEngineMessage();
  virtual ~GameEngineMessage();

  GameEngineMessage(const GameEngineMessage& from);

  inline GameEngineMessage& operator=(const GameEngineMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEngineMessage& default_instance();

  void Swap(GameEngineMessage* other);

  // implements Message ----------------------------------------------

  GameEngineMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEngineMessage& from);
  void MergeFrom(const GameEngineMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameEngineMessage_GameEngineMessageType GameEngineMessageType;
  static const GameEngineMessageType CREATE = GameEngineMessage_GameEngineMessageType_CREATE;
  static const GameEngineMessageType RETRIEVE = GameEngineMessage_GameEngineMessageType_RETRIEVE;
  static const GameEngineMessageType UPDATE = GameEngineMessage_GameEngineMessageType_UPDATE;
  static const GameEngineMessageType DELETE = GameEngineMessage_GameEngineMessageType_DELETE;
  static inline bool GameEngineMessageType_IsValid(int value) {
    return GameEngineMessage_GameEngineMessageType_IsValid(value);
  }
  static const GameEngineMessageType GameEngineMessageType_MIN =
    GameEngineMessage_GameEngineMessageType_GameEngineMessageType_MIN;
  static const GameEngineMessageType GameEngineMessageType_MAX =
    GameEngineMessage_GameEngineMessageType_GameEngineMessageType_MAX;
  static const int GameEngineMessageType_ARRAYSIZE =
    GameEngineMessage_GameEngineMessageType_GameEngineMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GameEngineMessageType_descriptor() {
    return GameEngineMessage_GameEngineMessageType_descriptor();
  }
  static inline const ::std::string& GameEngineMessageType_Name(GameEngineMessageType value) {
    return GameEngineMessage_GameEngineMessageType_Name(value);
  }
  static inline bool GameEngineMessageType_Parse(const ::std::string& name,
      GameEngineMessageType* value) {
    return GameEngineMessage_GameEngineMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .net.GameEngineMessage.GameEngineMessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::net::GameEngineMessage_GameEngineMessageType messagetype() const;
  inline void set_messagetype(::net::GameEngineMessage_GameEngineMessageType value);

  // repeated .net.PhysicsInfoMessage physicsInfo = 2;
  inline int physicsinfo_size() const;
  inline void clear_physicsinfo();
  static const int kPhysicsInfoFieldNumber = 2;
  inline const ::net::PhysicsInfoMessage& physicsinfo(int index) const;
  inline ::net::PhysicsInfoMessage* mutable_physicsinfo(int index);
  inline ::net::PhysicsInfoMessage* add_physicsinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::net::PhysicsInfoMessage >&
      physicsinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::net::PhysicsInfoMessage >*
      mutable_physicsinfo();

  // repeated .net.UpdateObjectMessage updateObject = 3;
  inline int updateobject_size() const;
  inline void clear_updateobject();
  static const int kUpdateObjectFieldNumber = 3;
  inline const ::net::UpdateObjectMessage& updateobject(int index) const;
  inline ::net::UpdateObjectMessage* mutable_updateobject(int index);
  inline ::net::UpdateObjectMessage* add_updateobject();
  inline const ::google::protobuf::RepeatedPtrField< ::net::UpdateObjectMessage >&
      updateobject() const;
  inline ::google::protobuf::RepeatedPtrField< ::net::UpdateObjectMessage >*
      mutable_updateobject();

  // repeated .net.DeleteObjectMessage deleteObject = 4;
  inline int deleteobject_size() const;
  inline void clear_deleteobject();
  static const int kDeleteObjectFieldNumber = 4;
  inline const ::net::DeleteObjectMessage& deleteobject(int index) const;
  inline ::net::DeleteObjectMessage* mutable_deleteobject(int index);
  inline ::net::DeleteObjectMessage* add_deleteobject();
  inline const ::google::protobuf::RepeatedPtrField< ::net::DeleteObjectMessage >&
      deleteobject() const;
  inline ::google::protobuf::RepeatedPtrField< ::net::DeleteObjectMessage >*
      mutable_deleteobject();

  // @@protoc_insertion_point(class_scope:net.GameEngineMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::net::PhysicsInfoMessage > physicsinfo_;
  ::google::protobuf::RepeatedPtrField< ::net::UpdateObjectMessage > updateobject_;
  ::google::protobuf::RepeatedPtrField< ::net::DeleteObjectMessage > deleteobject_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GameEngine_2eproto();
  friend void protobuf_AssignDesc_GameEngine_2eproto();
  friend void protobuf_ShutdownFile_GameEngine_2eproto();

  void InitAsDefaultInstance();
  static GameEngineMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// VelocityMessage

// required float x = 1;
inline bool VelocityMessage::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelocityMessage::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelocityMessage::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelocityMessage::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float VelocityMessage::x() const {
  return x_;
}
inline void VelocityMessage::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool VelocityMessage::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelocityMessage::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelocityMessage::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelocityMessage::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float VelocityMessage::y() const {
  return y_;
}
inline void VelocityMessage::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool VelocityMessage::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VelocityMessage::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VelocityMessage::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VelocityMessage::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float VelocityMessage::z() const {
  return z_;
}
inline void VelocityMessage::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// ForceMessage

// required float x = 1;
inline bool ForceMessage::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForceMessage::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForceMessage::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForceMessage::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ForceMessage::x() const {
  return x_;
}
inline void ForceMessage::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool ForceMessage::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForceMessage::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForceMessage::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForceMessage::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ForceMessage::y() const {
  return y_;
}
inline void ForceMessage::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool ForceMessage::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ForceMessage::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ForceMessage::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ForceMessage::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float ForceMessage::z() const {
  return z_;
}
inline void ForceMessage::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// PointMessage

// required float x = 1;
inline bool PointMessage::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointMessage::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointMessage::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointMessage::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointMessage::x() const {
  return x_;
}
inline void PointMessage::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool PointMessage::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointMessage::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointMessage::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointMessage::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointMessage::y() const {
  return y_;
}
inline void PointMessage::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool PointMessage::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointMessage::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointMessage::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointMessage::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float PointMessage::z() const {
  return z_;
}
inline void PointMessage::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// CollidableObjectMessage

// required int32 ID = 1;
inline bool CollidableObjectMessage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollidableObjectMessage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollidableObjectMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollidableObjectMessage::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CollidableObjectMessage::id() const {
  return id_;
}
inline void CollidableObjectMessage::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .net.PointMessage center = 2;
inline bool CollidableObjectMessage::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollidableObjectMessage::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollidableObjectMessage::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollidableObjectMessage::clear_center() {
  if (center_ != NULL) center_->::net::PointMessage::Clear();
  clear_has_center();
}
inline const ::net::PointMessage& CollidableObjectMessage::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::net::PointMessage* CollidableObjectMessage::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::net::PointMessage;
  return center_;
}
inline ::net::PointMessage* CollidableObjectMessage::release_center() {
  clear_has_center();
  ::net::PointMessage* temp = center_;
  center_ = NULL;
  return temp;
}
inline void CollidableObjectMessage::set_allocated_center(::net::PointMessage* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
}

// required int32 movable = 3;
inline bool CollidableObjectMessage::has_movable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollidableObjectMessage::set_has_movable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollidableObjectMessage::clear_has_movable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollidableObjectMessage::clear_movable() {
  movable_ = 0;
  clear_has_movable();
}
inline ::google::protobuf::int32 CollidableObjectMessage::movable() const {
  return movable_;
}
inline void CollidableObjectMessage::set_movable(::google::protobuf::int32 value) {
  set_has_movable();
  movable_ = value;
}

// -------------------------------------------------------------------

// AabbMessage

// required .net.CollidableObjectMessage collidableObject = 1;
inline bool AabbMessage::has_collidableobject() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AabbMessage::set_has_collidableobject() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AabbMessage::clear_has_collidableobject() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AabbMessage::clear_collidableobject() {
  if (collidableobject_ != NULL) collidableobject_->::net::CollidableObjectMessage::Clear();
  clear_has_collidableobject();
}
inline const ::net::CollidableObjectMessage& AabbMessage::collidableobject() const {
  return collidableobject_ != NULL ? *collidableobject_ : *default_instance_->collidableobject_;
}
inline ::net::CollidableObjectMessage* AabbMessage::mutable_collidableobject() {
  set_has_collidableobject();
  if (collidableobject_ == NULL) collidableobject_ = new ::net::CollidableObjectMessage;
  return collidableobject_;
}
inline ::net::CollidableObjectMessage* AabbMessage::release_collidableobject() {
  clear_has_collidableobject();
  ::net::CollidableObjectMessage* temp = collidableobject_;
  collidableobject_ = NULL;
  return temp;
}
inline void AabbMessage::set_allocated_collidableobject(::net::CollidableObjectMessage* collidableobject) {
  delete collidableobject_;
  collidableobject_ = collidableobject;
  if (collidableobject) {
    set_has_collidableobject();
  } else {
    clear_has_collidableobject();
  }
}

// required float radiusX = 2;
inline bool AabbMessage::has_radiusx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AabbMessage::set_has_radiusx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AabbMessage::clear_has_radiusx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AabbMessage::clear_radiusx() {
  radiusx_ = 0;
  clear_has_radiusx();
}
inline float AabbMessage::radiusx() const {
  return radiusx_;
}
inline void AabbMessage::set_radiusx(float value) {
  set_has_radiusx();
  radiusx_ = value;
}

// required float radiusY = 3;
inline bool AabbMessage::has_radiusy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AabbMessage::set_has_radiusy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AabbMessage::clear_has_radiusy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AabbMessage::clear_radiusy() {
  radiusy_ = 0;
  clear_has_radiusy();
}
inline float AabbMessage::radiusy() const {
  return radiusy_;
}
inline void AabbMessage::set_radiusy(float value) {
  set_has_radiusy();
  radiusy_ = value;
}

// required float radiusZ = 4;
inline bool AabbMessage::has_radiusz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AabbMessage::set_has_radiusz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AabbMessage::clear_has_radiusz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AabbMessage::clear_radiusz() {
  radiusz_ = 0;
  clear_has_radiusz();
}
inline float AabbMessage::radiusz() const {
  return radiusz_;
}
inline void AabbMessage::set_radiusz(float value) {
  set_has_radiusz();
  radiusz_ = value;
}

// -------------------------------------------------------------------

// SphereMessage

// required .net.CollidableObjectMessage collidableObject = 1;
inline bool SphereMessage::has_collidableobject() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SphereMessage::set_has_collidableobject() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SphereMessage::clear_has_collidableobject() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SphereMessage::clear_collidableobject() {
  if (collidableobject_ != NULL) collidableobject_->::net::CollidableObjectMessage::Clear();
  clear_has_collidableobject();
}
inline const ::net::CollidableObjectMessage& SphereMessage::collidableobject() const {
  return collidableobject_ != NULL ? *collidableobject_ : *default_instance_->collidableobject_;
}
inline ::net::CollidableObjectMessage* SphereMessage::mutable_collidableobject() {
  set_has_collidableobject();
  if (collidableobject_ == NULL) collidableobject_ = new ::net::CollidableObjectMessage;
  return collidableobject_;
}
inline ::net::CollidableObjectMessage* SphereMessage::release_collidableobject() {
  clear_has_collidableobject();
  ::net::CollidableObjectMessage* temp = collidableobject_;
  collidableobject_ = NULL;
  return temp;
}
inline void SphereMessage::set_allocated_collidableobject(::net::CollidableObjectMessage* collidableobject) {
  delete collidableobject_;
  collidableobject_ = collidableobject;
  if (collidableobject) {
    set_has_collidableobject();
  } else {
    clear_has_collidableobject();
  }
}

// required float radius = 2;
inline bool SphereMessage::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SphereMessage::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SphereMessage::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SphereMessage::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float SphereMessage::radius() const {
  return radius_;
}
inline void SphereMessage::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// PhysicsInfoMessage

// required .net.PhysicsInfoMessage.PhysicsInfoMessageType physicsInfoMessageType = 1;
inline bool PhysicsInfoMessage::has_physicsinfomessagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhysicsInfoMessage::set_has_physicsinfomessagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhysicsInfoMessage::clear_has_physicsinfomessagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhysicsInfoMessage::clear_physicsinfomessagetype() {
  physicsinfomessagetype_ = 0;
  clear_has_physicsinfomessagetype();
}
inline ::net::PhysicsInfoMessage_PhysicsInfoMessageType PhysicsInfoMessage::physicsinfomessagetype() const {
  return static_cast< ::net::PhysicsInfoMessage_PhysicsInfoMessageType >(physicsinfomessagetype_);
}
inline void PhysicsInfoMessage::set_physicsinfomessagetype(::net::PhysicsInfoMessage_PhysicsInfoMessageType value) {
  assert(::net::PhysicsInfoMessage_PhysicsInfoMessageType_IsValid(value));
  set_has_physicsinfomessagetype();
  physicsinfomessagetype_ = value;
}

// optional .net.AabbMessage aabbObject = 2;
inline bool PhysicsInfoMessage::has_aabbobject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhysicsInfoMessage::set_has_aabbobject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhysicsInfoMessage::clear_has_aabbobject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhysicsInfoMessage::clear_aabbobject() {
  if (aabbobject_ != NULL) aabbobject_->::net::AabbMessage::Clear();
  clear_has_aabbobject();
}
inline const ::net::AabbMessage& PhysicsInfoMessage::aabbobject() const {
  return aabbobject_ != NULL ? *aabbobject_ : *default_instance_->aabbobject_;
}
inline ::net::AabbMessage* PhysicsInfoMessage::mutable_aabbobject() {
  set_has_aabbobject();
  if (aabbobject_ == NULL) aabbobject_ = new ::net::AabbMessage;
  return aabbobject_;
}
inline ::net::AabbMessage* PhysicsInfoMessage::release_aabbobject() {
  clear_has_aabbobject();
  ::net::AabbMessage* temp = aabbobject_;
  aabbobject_ = NULL;
  return temp;
}
inline void PhysicsInfoMessage::set_allocated_aabbobject(::net::AabbMessage* aabbobject) {
  delete aabbobject_;
  aabbobject_ = aabbobject;
  if (aabbobject) {
    set_has_aabbobject();
  } else {
    clear_has_aabbobject();
  }
}

// optional .net.SphereMessage sphereObject = 3;
inline bool PhysicsInfoMessage::has_sphereobject() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhysicsInfoMessage::set_has_sphereobject() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhysicsInfoMessage::clear_has_sphereobject() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhysicsInfoMessage::clear_sphereobject() {
  if (sphereobject_ != NULL) sphereobject_->::net::SphereMessage::Clear();
  clear_has_sphereobject();
}
inline const ::net::SphereMessage& PhysicsInfoMessage::sphereobject() const {
  return sphereobject_ != NULL ? *sphereobject_ : *default_instance_->sphereobject_;
}
inline ::net::SphereMessage* PhysicsInfoMessage::mutable_sphereobject() {
  set_has_sphereobject();
  if (sphereobject_ == NULL) sphereobject_ = new ::net::SphereMessage;
  return sphereobject_;
}
inline ::net::SphereMessage* PhysicsInfoMessage::release_sphereobject() {
  clear_has_sphereobject();
  ::net::SphereMessage* temp = sphereobject_;
  sphereobject_ = NULL;
  return temp;
}
inline void PhysicsInfoMessage::set_allocated_sphereobject(::net::SphereMessage* sphereobject) {
  delete sphereobject_;
  sphereobject_ = sphereobject;
  if (sphereobject) {
    set_has_sphereobject();
  } else {
    clear_has_sphereobject();
  }
}

// required float mass = 4;
inline bool PhysicsInfoMessage::has_mass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PhysicsInfoMessage::set_has_mass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PhysicsInfoMessage::clear_has_mass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PhysicsInfoMessage::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float PhysicsInfoMessage::mass() const {
  return mass_;
}
inline void PhysicsInfoMessage::set_mass(float value) {
  set_has_mass();
  mass_ = value;
}

// required .net.VelocityMessage linearVelocity = 5;
inline bool PhysicsInfoMessage::has_linearvelocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PhysicsInfoMessage::set_has_linearvelocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PhysicsInfoMessage::clear_has_linearvelocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PhysicsInfoMessage::clear_linearvelocity() {
  if (linearvelocity_ != NULL) linearvelocity_->::net::VelocityMessage::Clear();
  clear_has_linearvelocity();
}
inline const ::net::VelocityMessage& PhysicsInfoMessage::linearvelocity() const {
  return linearvelocity_ != NULL ? *linearvelocity_ : *default_instance_->linearvelocity_;
}
inline ::net::VelocityMessage* PhysicsInfoMessage::mutable_linearvelocity() {
  set_has_linearvelocity();
  if (linearvelocity_ == NULL) linearvelocity_ = new ::net::VelocityMessage;
  return linearvelocity_;
}
inline ::net::VelocityMessage* PhysicsInfoMessage::release_linearvelocity() {
  clear_has_linearvelocity();
  ::net::VelocityMessage* temp = linearvelocity_;
  linearvelocity_ = NULL;
  return temp;
}
inline void PhysicsInfoMessage::set_allocated_linearvelocity(::net::VelocityMessage* linearvelocity) {
  delete linearvelocity_;
  linearvelocity_ = linearvelocity;
  if (linearvelocity) {
    set_has_linearvelocity();
  } else {
    clear_has_linearvelocity();
  }
}

// required .net.ForceMessage linearForce = 6;
inline bool PhysicsInfoMessage::has_linearforce() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PhysicsInfoMessage::set_has_linearforce() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PhysicsInfoMessage::clear_has_linearforce() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PhysicsInfoMessage::clear_linearforce() {
  if (linearforce_ != NULL) linearforce_->::net::ForceMessage::Clear();
  clear_has_linearforce();
}
inline const ::net::ForceMessage& PhysicsInfoMessage::linearforce() const {
  return linearforce_ != NULL ? *linearforce_ : *default_instance_->linearforce_;
}
inline ::net::ForceMessage* PhysicsInfoMessage::mutable_linearforce() {
  set_has_linearforce();
  if (linearforce_ == NULL) linearforce_ = new ::net::ForceMessage;
  return linearforce_;
}
inline ::net::ForceMessage* PhysicsInfoMessage::release_linearforce() {
  clear_has_linearforce();
  ::net::ForceMessage* temp = linearforce_;
  linearforce_ = NULL;
  return temp;
}
inline void PhysicsInfoMessage::set_allocated_linearforce(::net::ForceMessage* linearforce) {
  delete linearforce_;
  linearforce_ = linearforce;
  if (linearforce) {
    set_has_linearforce();
  } else {
    clear_has_linearforce();
  }
}

// required .net.VelocityMessage angularVelocity = 7;
inline bool PhysicsInfoMessage::has_angularvelocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PhysicsInfoMessage::set_has_angularvelocity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PhysicsInfoMessage::clear_has_angularvelocity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PhysicsInfoMessage::clear_angularvelocity() {
  if (angularvelocity_ != NULL) angularvelocity_->::net::VelocityMessage::Clear();
  clear_has_angularvelocity();
}
inline const ::net::VelocityMessage& PhysicsInfoMessage::angularvelocity() const {
  return angularvelocity_ != NULL ? *angularvelocity_ : *default_instance_->angularvelocity_;
}
inline ::net::VelocityMessage* PhysicsInfoMessage::mutable_angularvelocity() {
  set_has_angularvelocity();
  if (angularvelocity_ == NULL) angularvelocity_ = new ::net::VelocityMessage;
  return angularvelocity_;
}
inline ::net::VelocityMessage* PhysicsInfoMessage::release_angularvelocity() {
  clear_has_angularvelocity();
  ::net::VelocityMessage* temp = angularvelocity_;
  angularvelocity_ = NULL;
  return temp;
}
inline void PhysicsInfoMessage::set_allocated_angularvelocity(::net::VelocityMessage* angularvelocity) {
  delete angularvelocity_;
  angularvelocity_ = angularvelocity;
  if (angularvelocity) {
    set_has_angularvelocity();
  } else {
    clear_has_angularvelocity();
  }
}

// required .net.ForceMessage angularForce = 8;
inline bool PhysicsInfoMessage::has_angularforce() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PhysicsInfoMessage::set_has_angularforce() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PhysicsInfoMessage::clear_has_angularforce() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PhysicsInfoMessage::clear_angularforce() {
  if (angularforce_ != NULL) angularforce_->::net::ForceMessage::Clear();
  clear_has_angularforce();
}
inline const ::net::ForceMessage& PhysicsInfoMessage::angularforce() const {
  return angularforce_ != NULL ? *angularforce_ : *default_instance_->angularforce_;
}
inline ::net::ForceMessage* PhysicsInfoMessage::mutable_angularforce() {
  set_has_angularforce();
  if (angularforce_ == NULL) angularforce_ = new ::net::ForceMessage;
  return angularforce_;
}
inline ::net::ForceMessage* PhysicsInfoMessage::release_angularforce() {
  clear_has_angularforce();
  ::net::ForceMessage* temp = angularforce_;
  angularforce_ = NULL;
  return temp;
}
inline void PhysicsInfoMessage::set_allocated_angularforce(::net::ForceMessage* angularforce) {
  delete angularforce_;
  angularforce_ = angularforce;
  if (angularforce) {
    set_has_angularforce();
  } else {
    clear_has_angularforce();
  }
}

// required .net.PointMessage angularPosition = 9;
inline bool PhysicsInfoMessage::has_angularposition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PhysicsInfoMessage::set_has_angularposition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PhysicsInfoMessage::clear_has_angularposition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PhysicsInfoMessage::clear_angularposition() {
  if (angularposition_ != NULL) angularposition_->::net::PointMessage::Clear();
  clear_has_angularposition();
}
inline const ::net::PointMessage& PhysicsInfoMessage::angularposition() const {
  return angularposition_ != NULL ? *angularposition_ : *default_instance_->angularposition_;
}
inline ::net::PointMessage* PhysicsInfoMessage::mutable_angularposition() {
  set_has_angularposition();
  if (angularposition_ == NULL) angularposition_ = new ::net::PointMessage;
  return angularposition_;
}
inline ::net::PointMessage* PhysicsInfoMessage::release_angularposition() {
  clear_has_angularposition();
  ::net::PointMessage* temp = angularposition_;
  angularposition_ = NULL;
  return temp;
}
inline void PhysicsInfoMessage::set_allocated_angularposition(::net::PointMessage* angularposition) {
  delete angularposition_;
  angularposition_ = angularposition;
  if (angularposition) {
    set_has_angularposition();
  } else {
    clear_has_angularposition();
  }
}

// -------------------------------------------------------------------

// UpdateObjectMessage

// required int32 ID = 1;
inline bool UpdateObjectMessage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateObjectMessage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateObjectMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateObjectMessage::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UpdateObjectMessage::id() const {
  return id_;
}
inline void UpdateObjectMessage::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .net.PointMessage position = 2;
inline bool UpdateObjectMessage::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateObjectMessage::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateObjectMessage::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateObjectMessage::clear_position() {
  if (position_ != NULL) position_->::net::PointMessage::Clear();
  clear_has_position();
}
inline const ::net::PointMessage& UpdateObjectMessage::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::net::PointMessage* UpdateObjectMessage::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::net::PointMessage;
  return position_;
}
inline ::net::PointMessage* UpdateObjectMessage::release_position() {
  clear_has_position();
  ::net::PointMessage* temp = position_;
  position_ = NULL;
  return temp;
}
inline void UpdateObjectMessage::set_allocated_position(::net::PointMessage* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// -------------------------------------------------------------------

// DeleteObjectMessage

// required int32 ID = 1;
inline bool DeleteObjectMessage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteObjectMessage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteObjectMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteObjectMessage::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DeleteObjectMessage::id() const {
  return id_;
}
inline void DeleteObjectMessage::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// GameEngineMessage

// required .net.GameEngineMessage.GameEngineMessageType messageType = 1;
inline bool GameEngineMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameEngineMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameEngineMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameEngineMessage::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::net::GameEngineMessage_GameEngineMessageType GameEngineMessage::messagetype() const {
  return static_cast< ::net::GameEngineMessage_GameEngineMessageType >(messagetype_);
}
inline void GameEngineMessage::set_messagetype(::net::GameEngineMessage_GameEngineMessageType value) {
  assert(::net::GameEngineMessage_GameEngineMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// repeated .net.PhysicsInfoMessage physicsInfo = 2;
inline int GameEngineMessage::physicsinfo_size() const {
  return physicsinfo_.size();
}
inline void GameEngineMessage::clear_physicsinfo() {
  physicsinfo_.Clear();
}
inline const ::net::PhysicsInfoMessage& GameEngineMessage::physicsinfo(int index) const {
  return physicsinfo_.Get(index);
}
inline ::net::PhysicsInfoMessage* GameEngineMessage::mutable_physicsinfo(int index) {
  return physicsinfo_.Mutable(index);
}
inline ::net::PhysicsInfoMessage* GameEngineMessage::add_physicsinfo() {
  return physicsinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net::PhysicsInfoMessage >&
GameEngineMessage::physicsinfo() const {
  return physicsinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::net::PhysicsInfoMessage >*
GameEngineMessage::mutable_physicsinfo() {
  return &physicsinfo_;
}

// repeated .net.UpdateObjectMessage updateObject = 3;
inline int GameEngineMessage::updateobject_size() const {
  return updateobject_.size();
}
inline void GameEngineMessage::clear_updateobject() {
  updateobject_.Clear();
}
inline const ::net::UpdateObjectMessage& GameEngineMessage::updateobject(int index) const {
  return updateobject_.Get(index);
}
inline ::net::UpdateObjectMessage* GameEngineMessage::mutable_updateobject(int index) {
  return updateobject_.Mutable(index);
}
inline ::net::UpdateObjectMessage* GameEngineMessage::add_updateobject() {
  return updateobject_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net::UpdateObjectMessage >&
GameEngineMessage::updateobject() const {
  return updateobject_;
}
inline ::google::protobuf::RepeatedPtrField< ::net::UpdateObjectMessage >*
GameEngineMessage::mutable_updateobject() {
  return &updateobject_;
}

// repeated .net.DeleteObjectMessage deleteObject = 4;
inline int GameEngineMessage::deleteobject_size() const {
  return deleteobject_.size();
}
inline void GameEngineMessage::clear_deleteobject() {
  deleteobject_.Clear();
}
inline const ::net::DeleteObjectMessage& GameEngineMessage::deleteobject(int index) const {
  return deleteobject_.Get(index);
}
inline ::net::DeleteObjectMessage* GameEngineMessage::mutable_deleteobject(int index) {
  return deleteobject_.Mutable(index);
}
inline ::net::DeleteObjectMessage* GameEngineMessage::add_deleteobject() {
  return deleteobject_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net::DeleteObjectMessage >&
GameEngineMessage::deleteobject() const {
  return deleteobject_;
}
inline ::google::protobuf::RepeatedPtrField< ::net::DeleteObjectMessage >*
GameEngineMessage::mutable_deleteobject() {
  return &deleteobject_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace net

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::net::PhysicsInfoMessage_PhysicsInfoMessageType>() {
  return ::net::PhysicsInfoMessage_PhysicsInfoMessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::net::GameEngineMessage_GameEngineMessageType>() {
  return ::net::GameEngineMessage_GameEngineMessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameEngine_2eproto__INCLUDED
