// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameEngine.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "GameEngine.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace net {

namespace {

const ::google::protobuf::Descriptor* Velocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Velocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Force_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Force_reflection_ = NULL;
const ::google::protobuf::Descriptor* Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Point_reflection_ = NULL;
const ::google::protobuf::Descriptor* Aabb_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Aabb_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sphere_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sphere_reflection_ = NULL;
const ::google::protobuf::Descriptor* PhysicsInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PhysicsInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameEngine_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameEngine_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_GameEngine_2eproto() {
  protobuf_AddDesc_GameEngine_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "GameEngine.proto");
  GOOGLE_CHECK(file != NULL);
  Velocity_descriptor_ = file->message_type(0);
  static const int Velocity_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, z_),
  };
  Velocity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Velocity_descriptor_,
      Velocity::default_instance_,
      Velocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Velocity));
  Force_descriptor_ = file->message_type(1);
  static const int Force_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Force, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Force, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Force, z_),
  };
  Force_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Force_descriptor_,
      Force::default_instance_,
      Force_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Force, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Force, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Force));
  Point_descriptor_ = file->message_type(2);
  static const int Point_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, z_),
  };
  Point_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Point_descriptor_,
      Point::default_instance_,
      Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Point));
  Aabb_descriptor_ = file->message_type(3);
  static const int Aabb_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Aabb, center_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Aabb, radii_),
  };
  Aabb_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Aabb_descriptor_,
      Aabb::default_instance_,
      Aabb_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Aabb, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Aabb, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Aabb));
  Sphere_descriptor_ = file->message_type(4);
  static const int Sphere_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sphere, center_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sphere, radius_),
  };
  Sphere_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sphere_descriptor_,
      Sphere::default_instance_,
      Sphere_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sphere, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sphere, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sphere));
  PhysicsInfo_descriptor_ = file->message_type(5);
  static const int PhysicsInfo_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, mass_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, aabbobject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, sphereobject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, linearvelocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, angularvelocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, angularposition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, linearforce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, angularforce_),
  };
  PhysicsInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PhysicsInfo_descriptor_,
      PhysicsInfo::default_instance_,
      PhysicsInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicsInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PhysicsInfo));
  GameEngine_descriptor_ = file->message_type(6);
  static const int GameEngine_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameEngine, physicsinfo_),
  };
  GameEngine_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameEngine_descriptor_,
      GameEngine::default_instance_,
      GameEngine_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameEngine, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameEngine, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameEngine));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_GameEngine_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Velocity_descriptor_, &Velocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Force_descriptor_, &Force::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Point_descriptor_, &Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Aabb_descriptor_, &Aabb::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sphere_descriptor_, &Sphere::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PhysicsInfo_descriptor_, &PhysicsInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameEngine_descriptor_, &GameEngine::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_GameEngine_2eproto() {
  delete Velocity::default_instance_;
  delete Velocity_reflection_;
  delete Force::default_instance_;
  delete Force_reflection_;
  delete Point::default_instance_;
  delete Point_reflection_;
  delete Aabb::default_instance_;
  delete Aabb_reflection_;
  delete Sphere::default_instance_;
  delete Sphere_reflection_;
  delete PhysicsInfo::default_instance_;
  delete PhysicsInfo_reflection_;
  delete GameEngine::default_instance_;
  delete GameEngine_reflection_;
}

void protobuf_AddDesc_GameEngine_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020GameEngine.proto\022\003net\"+\n\010Velocity\022\t\n\001x"
    "\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"(\n\005Force\022\t\n"
    "\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"(\n\005Point\022"
    "\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"1\n\004Aabb"
    "\022\032\n\006center\030\001 \002(\0132\n.net.Point\022\r\n\005radii\030\002 "
    "\003(\002\"4\n\006Sphere\022\032\n\006center\030\001 \002(\0132\n.net.Poin"
    "t\022\016\n\006radius\030\002 \002(\002\"\224\002\n\013PhysicsInfo\022\014\n\004mas"
    "s\030\001 \002(\002\022\035\n\naabbObject\030\002 \002(\0132\t.net.Aabb\022!"
    "\n\014sphereObject\030\003 \002(\0132\013.net.Sphere\022%\n\016lin"
    "earVelocity\030\004 \002(\0132\r.net.Velocity\022&\n\017angu"
    "larVelocity\030\005 \002(\0132\r.net.Velocity\022#\n\017angu"
    "larPosition\030\006 \002(\0132\n.net.Point\022\037\n\013linearF"
    "orce\030\007 \002(\0132\n.net.Force\022 \n\014angularForce\030\010"
    " \002(\0132\n.net.Force\"3\n\nGameEngine\022%\n\013physic"
    "sInfo\030\001 \003(\0132\020.net.PhysicsInfo", 589);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "GameEngine.proto", &protobuf_RegisterTypes);
  Velocity::default_instance_ = new Velocity();
  Force::default_instance_ = new Force();
  Point::default_instance_ = new Point();
  Aabb::default_instance_ = new Aabb();
  Sphere::default_instance_ = new Sphere();
  PhysicsInfo::default_instance_ = new PhysicsInfo();
  GameEngine::default_instance_ = new GameEngine();
  Velocity::default_instance_->InitAsDefaultInstance();
  Force::default_instance_->InitAsDefaultInstance();
  Point::default_instance_->InitAsDefaultInstance();
  Aabb::default_instance_->InitAsDefaultInstance();
  Sphere::default_instance_->InitAsDefaultInstance();
  PhysicsInfo::default_instance_->InitAsDefaultInstance();
  GameEngine::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_GameEngine_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_GameEngine_2eproto {
  StaticDescriptorInitializer_GameEngine_2eproto() {
    protobuf_AddDesc_GameEngine_2eproto();
  }
} static_descriptor_initializer_GameEngine_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Velocity::kXFieldNumber;
const int Velocity::kYFieldNumber;
const int Velocity::kZFieldNumber;
#endif  // !_MSC_VER

Velocity::Velocity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Velocity::InitAsDefaultInstance() {
}

Velocity::Velocity(const Velocity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Velocity::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Velocity::~Velocity() {
  SharedDtor();
}

void Velocity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Velocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Velocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Velocity_descriptor_;
}

const Velocity& Velocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_GameEngine_2eproto();
  return *default_instance_;
}

Velocity* Velocity::default_instance_ = NULL;

Velocity* Velocity::New() const {
  return new Velocity;
}

void Velocity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Velocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Velocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Velocity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Velocity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Velocity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Velocity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Velocity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Velocity::MergeFrom(const Velocity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Velocity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Velocity::CopyFrom(const Velocity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Velocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Velocity::Swap(Velocity* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Velocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Velocity_descriptor_;
  metadata.reflection = Velocity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Force::kXFieldNumber;
const int Force::kYFieldNumber;
const int Force::kZFieldNumber;
#endif  // !_MSC_VER

Force::Force()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Force::InitAsDefaultInstance() {
}

Force::Force(const Force& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Force::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Force::~Force() {
  SharedDtor();
}

void Force::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Force::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Force::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Force_descriptor_;
}

const Force& Force::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_GameEngine_2eproto();
  return *default_instance_;
}

Force* Force::default_instance_ = NULL;

Force* Force::New() const {
  return new Force;
}

void Force::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Force::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Force::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Force::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Force::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Force::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Force* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Force*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Force::MergeFrom(const Force& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Force::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Force::CopyFrom(const Force& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Force::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Force::Swap(Force* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Force::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Force_descriptor_;
  metadata.reflection = Force_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Point::kXFieldNumber;
const int Point::kYFieldNumber;
const int Point::kZFieldNumber;
#endif  // !_MSC_VER

Point::Point()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Point::InitAsDefaultInstance() {
}

Point::Point(const Point& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Point::~Point() {
  SharedDtor();
}

void Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Point_descriptor_;
}

const Point& Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_GameEngine_2eproto();
  return *default_instance_;
}

Point* Point::default_instance_ = NULL;

Point* Point::New() const {
  return new Point;
}

void Point::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Point::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Point::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Point* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Point*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Point::MergeFrom(const Point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Point::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point::CopyFrom(const Point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Point::Swap(Point* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Point_descriptor_;
  metadata.reflection = Point_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Aabb::kCenterFieldNumber;
const int Aabb::kRadiiFieldNumber;
#endif  // !_MSC_VER

Aabb::Aabb()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Aabb::InitAsDefaultInstance() {
  center_ = const_cast< ::net::Point*>(&::net::Point::default_instance());
}

Aabb::Aabb(const Aabb& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Aabb::SharedCtor() {
  _cached_size_ = 0;
  center_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Aabb::~Aabb() {
  SharedDtor();
}

void Aabb::SharedDtor() {
  if (this != default_instance_) {
    delete center_;
  }
}

void Aabb::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Aabb::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Aabb_descriptor_;
}

const Aabb& Aabb::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_GameEngine_2eproto();
  return *default_instance_;
}

Aabb* Aabb::default_instance_ = NULL;

Aabb* Aabb::New() const {
  return new Aabb;
}

void Aabb::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_center()) {
      if (center_ != NULL) center_->::net::Point::Clear();
    }
  }
  radii_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Aabb::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .net.Point center = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_center()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_radii;
        break;
      }

      // repeated float radii = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radii:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_radii())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_radii())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_radii;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Aabb::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .net.Point center = 1;
  if (has_center()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->center(), output);
  }

  // repeated float radii = 2;
  for (int i = 0; i < this->radii_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->radii(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Aabb::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .net.Point center = 1;
  if (has_center()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->center(), target);
  }

  // repeated float radii = 2;
  for (int i = 0; i < this->radii_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->radii(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Aabb::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .net.Point center = 1;
    if (has_center()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->center());
    }

  }
  // repeated float radii = 2;
  {
    int data_size = 0;
    data_size = 4 * this->radii_size();
    total_size += 1 * this->radii_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Aabb::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Aabb* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Aabb*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Aabb::MergeFrom(const Aabb& from) {
  GOOGLE_CHECK_NE(&from, this);
  radii_.MergeFrom(from.radii_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_center()) {
      mutable_center()->::net::Point::MergeFrom(from.center());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Aabb::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Aabb::CopyFrom(const Aabb& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Aabb::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_center()) {
    if (!this->center().IsInitialized()) return false;
  }
  return true;
}

void Aabb::Swap(Aabb* other) {
  if (other != this) {
    std::swap(center_, other->center_);
    radii_.Swap(&other->radii_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Aabb::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Aabb_descriptor_;
  metadata.reflection = Aabb_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Sphere::kCenterFieldNumber;
const int Sphere::kRadiusFieldNumber;
#endif  // !_MSC_VER

Sphere::Sphere()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Sphere::InitAsDefaultInstance() {
  center_ = const_cast< ::net::Point*>(&::net::Point::default_instance());
}

Sphere::Sphere(const Sphere& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Sphere::SharedCtor() {
  _cached_size_ = 0;
  center_ = NULL;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sphere::~Sphere() {
  SharedDtor();
}

void Sphere::SharedDtor() {
  if (this != default_instance_) {
    delete center_;
  }
}

void Sphere::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sphere::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sphere_descriptor_;
}

const Sphere& Sphere::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_GameEngine_2eproto();
  return *default_instance_;
}

Sphere* Sphere::default_instance_ = NULL;

Sphere* Sphere::New() const {
  return new Sphere;
}

void Sphere::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_center()) {
      if (center_ != NULL) center_->::net::Point::Clear();
    }
    radius_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sphere::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .net.Point center = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_center()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_radius;
        break;
      }

      // required float radius = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Sphere::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .net.Point center = 1;
  if (has_center()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->center(), output);
  }

  // required float radius = 2;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Sphere::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .net.Point center = 1;
  if (has_center()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->center(), target);
  }

  // required float radius = 2;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Sphere::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .net.Point center = 1;
    if (has_center()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->center());
    }

    // required float radius = 2;
    if (has_radius()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sphere::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sphere* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sphere*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sphere::MergeFrom(const Sphere& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_center()) {
      mutable_center()->::net::Point::MergeFrom(from.center());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sphere::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sphere::CopyFrom(const Sphere& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sphere::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_center()) {
    if (!this->center().IsInitialized()) return false;
  }
  return true;
}

void Sphere::Swap(Sphere* other) {
  if (other != this) {
    std::swap(center_, other->center_);
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sphere::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sphere_descriptor_;
  metadata.reflection = Sphere_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PhysicsInfo::kMassFieldNumber;
const int PhysicsInfo::kAabbObjectFieldNumber;
const int PhysicsInfo::kSphereObjectFieldNumber;
const int PhysicsInfo::kLinearVelocityFieldNumber;
const int PhysicsInfo::kAngularVelocityFieldNumber;
const int PhysicsInfo::kAngularPositionFieldNumber;
const int PhysicsInfo::kLinearForceFieldNumber;
const int PhysicsInfo::kAngularForceFieldNumber;
#endif  // !_MSC_VER

PhysicsInfo::PhysicsInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PhysicsInfo::InitAsDefaultInstance() {
  aabbobject_ = const_cast< ::net::Aabb*>(&::net::Aabb::default_instance());
  sphereobject_ = const_cast< ::net::Sphere*>(&::net::Sphere::default_instance());
  linearvelocity_ = const_cast< ::net::Velocity*>(&::net::Velocity::default_instance());
  angularvelocity_ = const_cast< ::net::Velocity*>(&::net::Velocity::default_instance());
  angularposition_ = const_cast< ::net::Point*>(&::net::Point::default_instance());
  linearforce_ = const_cast< ::net::Force*>(&::net::Force::default_instance());
  angularforce_ = const_cast< ::net::Force*>(&::net::Force::default_instance());
}

PhysicsInfo::PhysicsInfo(const PhysicsInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PhysicsInfo::SharedCtor() {
  _cached_size_ = 0;
  mass_ = 0;
  aabbobject_ = NULL;
  sphereobject_ = NULL;
  linearvelocity_ = NULL;
  angularvelocity_ = NULL;
  angularposition_ = NULL;
  linearforce_ = NULL;
  angularforce_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PhysicsInfo::~PhysicsInfo() {
  SharedDtor();
}

void PhysicsInfo::SharedDtor() {
  if (this != default_instance_) {
    delete aabbobject_;
    delete sphereobject_;
    delete linearvelocity_;
    delete angularvelocity_;
    delete angularposition_;
    delete linearforce_;
    delete angularforce_;
  }
}

void PhysicsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PhysicsInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PhysicsInfo_descriptor_;
}

const PhysicsInfo& PhysicsInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_GameEngine_2eproto();
  return *default_instance_;
}

PhysicsInfo* PhysicsInfo::default_instance_ = NULL;

PhysicsInfo* PhysicsInfo::New() const {
  return new PhysicsInfo;
}

void PhysicsInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mass_ = 0;
    if (has_aabbobject()) {
      if (aabbobject_ != NULL) aabbobject_->::net::Aabb::Clear();
    }
    if (has_sphereobject()) {
      if (sphereobject_ != NULL) sphereobject_->::net::Sphere::Clear();
    }
    if (has_linearvelocity()) {
      if (linearvelocity_ != NULL) linearvelocity_->::net::Velocity::Clear();
    }
    if (has_angularvelocity()) {
      if (angularvelocity_ != NULL) angularvelocity_->::net::Velocity::Clear();
    }
    if (has_angularposition()) {
      if (angularposition_ != NULL) angularposition_->::net::Point::Clear();
    }
    if (has_linearforce()) {
      if (linearforce_ != NULL) linearforce_->::net::Force::Clear();
    }
    if (has_angularforce()) {
      if (angularforce_ != NULL) angularforce_->::net::Force::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PhysicsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float mass = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mass_)));
          set_has_mass();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_aabbObject;
        break;
      }

      // required .net.Aabb aabbObject = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aabbObject:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_aabbobject()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sphereObject;
        break;
      }

      // required .net.Sphere sphereObject = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sphereObject:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sphereobject()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_linearVelocity;
        break;
      }

      // required .net.Velocity linearVelocity = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_linearVelocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linearvelocity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_angularVelocity;
        break;
      }

      // required .net.Velocity angularVelocity = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_angularVelocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angularvelocity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_angularPosition;
        break;
      }

      // required .net.Point angularPosition = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_angularPosition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angularposition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_linearForce;
        break;
      }

      // required .net.Force linearForce = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_linearForce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linearforce()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_angularForce;
        break;
      }

      // required .net.Force angularForce = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_angularForce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angularforce()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PhysicsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float mass = 1;
  if (has_mass()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->mass(), output);
  }

  // required .net.Aabb aabbObject = 2;
  if (has_aabbobject()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->aabbobject(), output);
  }

  // required .net.Sphere sphereObject = 3;
  if (has_sphereobject()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sphereobject(), output);
  }

  // required .net.Velocity linearVelocity = 4;
  if (has_linearvelocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->linearvelocity(), output);
  }

  // required .net.Velocity angularVelocity = 5;
  if (has_angularvelocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->angularvelocity(), output);
  }

  // required .net.Point angularPosition = 6;
  if (has_angularposition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->angularposition(), output);
  }

  // required .net.Force linearForce = 7;
  if (has_linearforce()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->linearforce(), output);
  }

  // required .net.Force angularForce = 8;
  if (has_angularforce()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->angularforce(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PhysicsInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float mass = 1;
  if (has_mass()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->mass(), target);
  }

  // required .net.Aabb aabbObject = 2;
  if (has_aabbobject()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->aabbobject(), target);
  }

  // required .net.Sphere sphereObject = 3;
  if (has_sphereobject()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sphereobject(), target);
  }

  // required .net.Velocity linearVelocity = 4;
  if (has_linearvelocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->linearvelocity(), target);
  }

  // required .net.Velocity angularVelocity = 5;
  if (has_angularvelocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->angularvelocity(), target);
  }

  // required .net.Point angularPosition = 6;
  if (has_angularposition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->angularposition(), target);
  }

  // required .net.Force linearForce = 7;
  if (has_linearforce()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->linearforce(), target);
  }

  // required .net.Force angularForce = 8;
  if (has_angularforce()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->angularforce(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PhysicsInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float mass = 1;
    if (has_mass()) {
      total_size += 1 + 4;
    }

    // required .net.Aabb aabbObject = 2;
    if (has_aabbobject()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->aabbobject());
    }

    // required .net.Sphere sphereObject = 3;
    if (has_sphereobject()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sphereobject());
    }

    // required .net.Velocity linearVelocity = 4;
    if (has_linearvelocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->linearvelocity());
    }

    // required .net.Velocity angularVelocity = 5;
    if (has_angularvelocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->angularvelocity());
    }

    // required .net.Point angularPosition = 6;
    if (has_angularposition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->angularposition());
    }

    // required .net.Force linearForce = 7;
    if (has_linearforce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->linearforce());
    }

    // required .net.Force angularForce = 8;
    if (has_angularforce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->angularforce());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PhysicsInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PhysicsInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PhysicsInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PhysicsInfo::MergeFrom(const PhysicsInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mass()) {
      set_mass(from.mass());
    }
    if (from.has_aabbobject()) {
      mutable_aabbobject()->::net::Aabb::MergeFrom(from.aabbobject());
    }
    if (from.has_sphereobject()) {
      mutable_sphereobject()->::net::Sphere::MergeFrom(from.sphereobject());
    }
    if (from.has_linearvelocity()) {
      mutable_linearvelocity()->::net::Velocity::MergeFrom(from.linearvelocity());
    }
    if (from.has_angularvelocity()) {
      mutable_angularvelocity()->::net::Velocity::MergeFrom(from.angularvelocity());
    }
    if (from.has_angularposition()) {
      mutable_angularposition()->::net::Point::MergeFrom(from.angularposition());
    }
    if (from.has_linearforce()) {
      mutable_linearforce()->::net::Force::MergeFrom(from.linearforce());
    }
    if (from.has_angularforce()) {
      mutable_angularforce()->::net::Force::MergeFrom(from.angularforce());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PhysicsInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PhysicsInfo::CopyFrom(const PhysicsInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhysicsInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_aabbobject()) {
    if (!this->aabbobject().IsInitialized()) return false;
  }
  if (has_sphereobject()) {
    if (!this->sphereobject().IsInitialized()) return false;
  }
  if (has_linearvelocity()) {
    if (!this->linearvelocity().IsInitialized()) return false;
  }
  if (has_angularvelocity()) {
    if (!this->angularvelocity().IsInitialized()) return false;
  }
  if (has_angularposition()) {
    if (!this->angularposition().IsInitialized()) return false;
  }
  if (has_linearforce()) {
    if (!this->linearforce().IsInitialized()) return false;
  }
  if (has_angularforce()) {
    if (!this->angularforce().IsInitialized()) return false;
  }
  return true;
}

void PhysicsInfo::Swap(PhysicsInfo* other) {
  if (other != this) {
    std::swap(mass_, other->mass_);
    std::swap(aabbobject_, other->aabbobject_);
    std::swap(sphereobject_, other->sphereobject_);
    std::swap(linearvelocity_, other->linearvelocity_);
    std::swap(angularvelocity_, other->angularvelocity_);
    std::swap(angularposition_, other->angularposition_);
    std::swap(linearforce_, other->linearforce_);
    std::swap(angularforce_, other->angularforce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PhysicsInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PhysicsInfo_descriptor_;
  metadata.reflection = PhysicsInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GameEngine::kPhysicsInfoFieldNumber;
#endif  // !_MSC_VER

GameEngine::GameEngine()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameEngine::InitAsDefaultInstance() {
}

GameEngine::GameEngine(const GameEngine& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameEngine::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameEngine::~GameEngine() {
  SharedDtor();
}

void GameEngine::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GameEngine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameEngine::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameEngine_descriptor_;
}

const GameEngine& GameEngine::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_GameEngine_2eproto();
  return *default_instance_;
}

GameEngine* GameEngine::default_instance_ = NULL;

GameEngine* GameEngine::New() const {
  return new GameEngine;
}

void GameEngine::Clear() {
  physicsinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameEngine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .net.PhysicsInfo physicsInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_physicsInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_physicsinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_physicsInfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GameEngine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .net.PhysicsInfo physicsInfo = 1;
  for (int i = 0; i < this->physicsinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->physicsinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameEngine::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .net.PhysicsInfo physicsInfo = 1;
  for (int i = 0; i < this->physicsinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->physicsinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameEngine::ByteSize() const {
  int total_size = 0;

  // repeated .net.PhysicsInfo physicsInfo = 1;
  total_size += 1 * this->physicsinfo_size();
  for (int i = 0; i < this->physicsinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->physicsinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameEngine::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameEngine* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameEngine*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameEngine::MergeFrom(const GameEngine& from) {
  GOOGLE_CHECK_NE(&from, this);
  physicsinfo_.MergeFrom(from.physicsinfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameEngine::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEngine::CopyFrom(const GameEngine& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEngine::IsInitialized() const {

  for (int i = 0; i < physicsinfo_size(); i++) {
    if (!this->physicsinfo(i).IsInitialized()) return false;
  }
  return true;
}

void GameEngine::Swap(GameEngine* other) {
  if (other != this) {
    physicsinfo_.Swap(&other->physicsinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameEngine::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameEngine_descriptor_;
  metadata.reflection = GameEngine_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace net

// @@protoc_insertion_point(global_scope)
